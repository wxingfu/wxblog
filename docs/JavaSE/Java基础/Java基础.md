---
title: Java基础
date: 2022-03-06
categories:
- Java
- 后端
tags:
- Java
- 后端
---

::: tip
Java基础知识点
:::

<!-- more -->

## 基础概念

#### **Java语言特点**

> 1.简单易学
>
> 2.面向对象编程
>
> 3.平台无关性、可靠性、安全性
>
> 4.支持多线程、支持网络编程
>
> 5.编译与解释并存



#### **JDK 和 JRE**

- JDK 是 Java Development Kit 缩写，包含JRE 、编译器和工具。它能够创建和编译程序。
- JRE 是 Java 运行时环境，运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。不能用于创建新程序。



#### **Java 和 C++ 的一些区别**

相同点：

- Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态

不同点：

- Java 不提供指针来直接访问内存，程序内存更加安全
- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。
- Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。
- C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载



## 基本语法

#### **字符串常量和字符常量区别**

- 字符串常量是双引号引起的0个或多个字符，字符常量是单引号引起的一个字符。
- 字符串常量是地址引用，字符常量可以用ASCII码表示



#### **注释**

- 单行注释：// 注释内容
- 多行注释：/\*注释内容\*/
- 文档注释：/\*\*注释内容\*/



#### **continue、break 和 return 的区别**

- `continue` ：指跳出当前的这一次循环，继续下一次循环。
- `break` ：指跳出整个循环体，继续执行循环下面的语句。
- `return` 用于跳出所在方法，结束该方法的运行。



#### **静态方法为什么不能调用非静态成员**

- 静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。

- 在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。



#### **静态方法和实例方法不同点**

- 调用方式

> 静态方法：类名.方法名
>
> 
>
> 实例方法：对象.方法名

- 访问类成员是否存在限制

> 静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。

#### **重载和重写**

**重载**

> 发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。

**重写**

> 重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。
>
> 1. 方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。
> 2. 如果父类方法访问修饰符为 `private/final/static` 则子类就不能重写该方法，但是被 `static` 修饰的方法能够被再次声明。
> 3. 构造方法无法被重写

#### **== 和 equals()** 

- `==`对于基本类型和引用类型的作用效果是不同的：
  - 对于基本数据类型来说，`==` 比较的是值。
  - 对于引用数据类型来说，`==` 比较的是对象的内存地址。

- `equals()`不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。`equals()`方法存在于`Object`类中，而`Object`类是所有类的直接或间接父类，因此所有的类都有`equals()`方法。`equals()` 方法存在两种使用情况：

> 类没有重写 `equals()`方法 ：通过`equals()`比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 `Object`类`equals()`方法。
>
> 
>
> 类重写了 `equals()`方法 ：一般我们都重写 `equals()`方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。

```java
String a = new String("ab"); // a 为一个引用
String b = new String("ab"); // b为另一个引用,对象的内容一样
String aa = "ab"; // 放在常量池中
String bb = "ab"; // 从常量池中查找
System.out.println(aa == bb);// true
System.out.println(a == b);// false
System.out.println(a.equals(b));// true
System.out.println(42 == 42.0);// true
```

#### **为什么重写 equals() 时必须重写 hashCode() 方法**

>  因为两个相等的对象的 `hashCode` 值必须是相等。也就是说如果 `equals` 方法判断两个对象是相等的，那这两个对象的 `hashCode` 值也要相等。
>
> 
>
> 如果重写 `equals()` 时没有重写 `hashCode()` 方法的话就可能会导致 `equals` 方法判断是相等的两个对象，`hashCode` 值却不相等。



## 基本数据类型

#### 8种基本数据类型

- 6种数字类型
  - 4种整数型：`byte(2字节)`,`short(2字节)`,`int(4字节)`,`long(8字节)`
  - 2种浮点型：`float(4字节)`,`double(8字节)`
- 1种字符型：`char(2字节)`
- 1中布尔型：`boolean`

八种基本类型都有对应的包装类分别为：`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean`

```java
Integer i1 = 40; // 等价Integer i1=Integer.valueOf(40)
Integer i2 = new Integer(40);
System.out.println(i1==i2);// false,对象不同
```

#### 自动装箱与拆箱

- **装箱**：将基本类型用它们对应的引用类型包装起来；
- **拆箱**：将包装类型转换为基本数据类型；





## 参考

- [JavaGuide](https://javaguide.cn/)
